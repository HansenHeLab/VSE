#!/usr/bin/perl -w

=pod
=head1 VSE

VSE is a Perl/Rscript command line tool to calculate the enrichment of associated variant set (AVS) for an array of genomic regions.

=head1 SYNOPSIS

The VSE is comprised of three modules. Each module can be run independantly.

=over 14

=item C<preprocess>

perl vse preprocess --tag example.SNPs/NHGRI-BCa.bed --ld example.SNPs/ld_BCa.bed --output vse

=item C<vse>

perl vse vse --avs vse.avs --tally vse.tally --bedDir beds/ --mrvsDir vse.MRVS/ --output vse-out

=item C<stat>

perl vse stat --vse vse-out.VSE.txt --matrix vse-out.matrix.txt --out vse-result

=back

=head1 OPTIONS

vse preprocess

=over 12

=item B<--tag>

Location to tag SNPs' list. Please check the documentation for file format.

=item B<--ld>

Location to LD SNPs' list. Please check the documentation for file format.

=item B<--out>

Output file prefix.

=item B<-r>

The r value used for determining LD SNPs. Must be between 0.6 and 1. Default: 0.8

=item B<--phase>

The 1000 Genome Project data used to calculate LD blocks. Must be 1 or 3. Default: 1

=item B<--bgSize>

The number of MRVS to compute. The default of 100 is sufficient for normal uses. Higher number is computionally heavier and is not recommended for typical uses.

=item B<--n>

The number of threads to use. Default: 4

=item B<--mrvs>

Location to the directory where MRVS files are

=back

vse vse

=over 12

=item B<--avs>

Location to AVS file generated from "preprocess"

=item B<--tally>

Location to tally file generated from "preprocess"

=item B<--mrvsDir>

Location to MRVS directory

=item B<--bedDir>

Location to directory that contains all genomic features. The files in the directory must be bed or narrowPeak files.

=item B<--out>

Output prefix.

=back

vse stat

=over 12

=item -B<--vse>

Location to VSE output file generated from "vse".
=item -B<--matrix>

Location to matrix file generated from "vse".

=item -B<--out>

Output prefix.

=back

=cut

use strict;
use Getopt::Long;
use Pod::Usage;
use Cwd 'abs_path';
use FindBin qw($Bin);
use lib "$Bin/lib";
use LDX_to_LDXI;
use tally;
use LDX_v_bed;

use Data::Dumper;

#----ARGUMENTS-----------
my $program = $ARGV[0];
my $tagFile = "";
my $ldFile = "";
my $avsFile = "";
my $tallyFile = "";
my $r = 0.8;
my $bgSize = 100;
my $kgpPhase = 1;
my $outputPrefix = "vse";
my $mrvsDir = "";
my $bedDir = "";
my $vseFile = "";
my $matrixFile = "";
my $totalForks = 4; 
my $scriptPath = abs_path($0);
my @pathArr = split (/[\/\\]/, $scriptPath);
my $scriptDir = join ("/", @pathArr[0..$#pathArr-1]);
my $quiet;
my $help = 0;
my $man = 0;

GetOptions ("i|tag=s" => \$tagFile,
	    "l|ld=s" => \$ldFile,
	    "r=f" => \$r,
	    "bgSize=i" => \$bgSize,
	    "n=i" => \$totalForks,
	    "bedDir=s" => \$bedDir,
	    "avs=s" => \$avsFile,
	    "tally=s" => \$tallyFile,
	    "p|phase=i" => \$kgpPhase,
	    "o|output=s" => \$outputPrefix,
	    "m|mrvsDir=s" => \$mrvsDir,
	    "vse=s" => \$vseFile,
	    "matrix=s" => \$matrixFile,
	    "q|quiet!" => \$quiet,
	    "h|help|?!" => \$help,
	    "man" => \$man
    ) or pod2usage(2);
pod2usage(1) if $help;
pod2usage(-exitval => 0, -verbose => 2) if $man;

#------------------------


#----------subroutines---------------
sub printLog
{
    my $line = shift;
    if (!$quiet){
	print localtime()." $line\n";
    }
}

sub removeExtension
{
    my $name = shift;
    my @bedfileName_arr = split /\./, $name;
    my $bedfileName = $bedfileName_arr[0];
    return $bedfileName;
}

sub loadTagSNPs
{
    my $AVS = shift;
    my @tagSNPs;
    open (HIN, "grep \"#\" $AVS | cut -d \" \" -f 3 |") or die "Could not open $AVS file: $!\n";
    while (<HIN>){
        chomp;
        push (@tagSNPs, $_);
    }
    close HIN;
    return \@tagSNPs;
}

sub loadFileIntoArray
{
    my $file = shift;
    my @lines;
    open (INF, "<$file") or die "Could not open $file: $!\n";
    while (<INF>){
	chomp;
	push @lines, $_;
    }
    close INF;
    return \@lines;
}

sub lineCount
{
    my $inputfile = shift;
    my $totalTagSnp=`wc -l < $inputfile`;
    $totalTagSnp =~ s/^\s+//;
    chomp $totalTagSnp;
    return $totalTagSnp;
}
#-------------------------


#-------INPUT QC---------

#Check parameters
die "The program must be any of \"preprocess\", \"vse\" or \"stat\" .\nExample: perl $0 --help\n" if (!$ARGV[0] || $program !~ m/(preprocess|vse|stat)/);

#------------------------

#------------------------PREPROCESS---------------------------------->
if ($program =~ m/preprocess/){
    printLog("Preparing AVS file");
    
    #QC
    die "-r must be between 0.6 and 1\n" if $r <0.6 || $r > 1;
    die "parameter missing\n" if ($tagFile eq "" || $ldFile eq "");
    die "$tagFile file not found\n" if (! -e $tagFile);
    die "$ldFile file not found\n" if (! -e $ldFile);
    my $totalTagSnp=lineCount($tagFile);
    die "$tagFile does not have any snp\n" if ($totalTagSnp == 0);
    my $totalColumnInLD = `awk '{print NF}' $ldFile | sort -u | wc -l`;
    die "Column number is not same for all lines in $ldFile\n" if $totalColumnInLD != 1;


    my $ldxFile = $outputPrefix.".LDX.bed";
    $avsFile = $outputPrefix.".avs" if $avsFile eq "";
    $tallyFile = $outputPrefix.".avs.tally" if $tallyFile eq "";
    my $lines = loadFileIntoArray($tagFile);
    die "$tagFile looks empty\n" if scalar @$lines == 0;
    my $lineCounter = 1;
    open (OUT, ">$ldxFile") or die "Count not open $ldxFile for writing: $!\n";
    foreach my $line (@$lines){
	my @f = split /\t/, $line;
	my $totalColumns = $#f + 1;
	die "Line $lineCounter has $totalColumns columns instead of 4 in $tagFile\n" if $totalColumns < 3;
	my $header= "# raSNP $f[3]\n";
	print OUT $header;
	open (IN, "awk -v tag=$f[3] '\$5==tag' $ldFile |") or die;
	while (<IN>){
	    chomp;
	    my @g = split /\t/;
	    if ($g[4] ne $g[3]){ #skip tag snp itself
		my $printline = "$g[0]\t$g[1]\t$g[2]\n";
		print OUT $printline;
	    }
	}
	close IN;
	$lineCounter++;
    }
    close OUT;
    LDX_to_LDXI($ldxFile,$avsFile);
    printLog("$avsFile created");
    my $highestTally = tally($avsFile,$tallyFile);
    printLog("$tallyFile created");
    unlink($ldxFile);

    #----------Computing MRVSs------------------>

    #Create mrvs directory
    $mrvsDir = $outputPrefix.".MRVS" if $mrvsDir eq "";
    if (! -d $mrvsDir){
	mkdir $mrvsDir;
    } else {
	printLog("$mrvsDir exists. Will overwrite");
    }

    #Local variables
    my @SNPS; #null tallies from database
    my @AV; #AVS tallies
    my @RA; #AVS LDXI IDs
    my %blocks; #null LD blocks

    #Finding null tally file
    my $null_tally_file = $scriptDir."/data/phaseI/ld_tally_r".$r.".txt.gz";
    if ($kgpPhase == 3){
	$null_tally_file = $scriptDir."/data/phaseIII/ld_tally_r".$r.".txt.gz";
    }
    die "-r seems wrong!\n" if (!-e $null_tally_file);

    my %nullIds;

    #Load null tallies
    open (SNPS, "gunzip -c $null_tally_file |") or die "$!\n";
    while(<SNPS>){ 
	chomp;
	my ($id,$tally) = split /\t/;
	next if /SNP/;
	next if $tally > $highestTally;
	push (@{ $SNPS[$tally] }, $id);
	$nullIds{$id} = 1;
    }
    close SNPS;

    #Load AVS tallies
    open (AV, "<$tallyFile") or die "$!\n";
    while (<AV>){
	chomp;
	my ($id, $tally) = split/ /;
	push @AV, $tally;
	push @RA, $id;
	foreach my $i (0..$#{ $SNPS[ $tally ] }){ #looping through null sets with identical tally
	    if( $id =~ ${ $SNPS[ $tally ] }[$i] ){ #if AVS snp exists in null set
		splice( @{ $SNPS[ $tally ] }, $i, 1 ); #remove the AVS snp from null set
	    }
	}
    }
    close AV;

    #Load null LD blocks
    printLog("Saving LD block into memory");
    foreach my $i (1..22){
	printLog("chr$i");
	if ($kgpPhase == 1){
	    open (IN, "gunzip -c $scriptDir/data/phaseI/chr${i}.ld.gz |") or die;
	} else {
	    open (IN, "gunzip -c $scriptDir/data/phaseIII/chr${i}.ld.gz |") or die;
	}
	my $header=<IN>;
	while (<IN>){
	    chomp;
	    my @f = split /\t/;
	    next if $f[$#f] < $r; #skip LD if r is less than the cutoff
	    my $chr = "chr".$i;
	    my $tag = "chr".$i.":".$f[1];
	    next if !exists $nullIds{$tag};
	    my $ld = "chr".$i.":".$f[4];
	    if (exists $blocks{$chr}->{$tag}){
		$blocks{$chr}->{$tag} .= ",".$ld;
	    } else {
		$blocks{$chr}->{$tag} = $ld; #Save ld blocks in %block
	    }
	}
	close IN;
    }
    
    #Writing MRVSs
    printLog("Writing MRVs in $mrvsDir");
    # my $delim = int $bgSize / $totalForks;
    # my $forks = 1; #fork counter  
    # for (1..$totalForks){
    # 	my $pid = fork();
    # 	if (not defined $pid){
    # 	    warn 'Could not fork';
    # 	    next;
    # 	}
    # 	if ($pid){ #parent process
    # 	    $forks++; #count the number of child processes
    # 	} else { #child process
    # 	    my $from = $forks == 1 ? 1 : ($forks * $delim) - ($delim - 1);
    # 	    my $to = $forks == $totalForks ? $bgSize :  $forks * $delim;
    # 	    foreach my $file ($from..$to){
    foreach my $file(1..$bgSize){
		$file = $mrvsDir."/".$file;
		open (OUT, ">$file") or die;
		printLog("Writing to $file");
		foreach my $i (0..$#AV){ #loop through risk loci
		    if ($#{$SNPS[$AV[$i]]} < 1){ #there is no null LD block of identical size
			$AV[$i]-=1 until $#{$SNPS[$AV[$i]]} > 1; #Reduce the size of risk LD block by one until a matched null set is found
		    }
		    my @nullLd = @{$SNPS[$AV[$i]]}; #array of all null LD blocks with similar size as risk locus
		    my $rand = int(rand( $#nullLd + 1)); #randomly choose one null LD block
		    my $nullTagId = $nullLd[$rand]; #tag SNP of the null LD block
		    print "$nullTagId\t";
		    my ($LDchr,$LDpos) = $nullTagId =~ m/:/ ? split (/:/, $nullTagId) : die $nullTagId;
		    if (!exists $blocks{$LDchr}->{$nullTagId}){
			$rand = int(rand( $#nullLd + 1)) until (exists $blocks{$LDchr}->{${ $SNPS[ $AV[$i]] }[$r]});
		    }
		    $nullTagId = $nullLd[$rand];
		    print "$nullTagId\n";
		    print OUT "# raSNP ".$RA[ $i ]."\n";
		    if ($blocks{$LDchr}->{$nullTagId} =~ m/,/){
			my @LDsnps = split (/,/,$blocks{$LDchr}->{$nullTagId});
			foreach my $LDsnp (@LDsnps){
			    my ($c,$s) = split (/:/, $LDsnp);
			    my $e = $s+1;
			    print OUT "$c\t$s\t$e\n";
			}
		    } else {
			my ($c,$s) = split (/:/,$blocks{$LDchr}->{$nullTagId});
			my $e =$s+1;
			print OUT "$c\t$s\t$e\n";
		    }
		}
		close OUT;
	    }
#	    exit;
#	}
#    }
#    for (1..$forks){
#	my $pid = wait();
#    }
}
#<-----------------------PREPROCESS----------------------------------


#---------------------------STAT------------------------------------>

if ($program =~ m/vse/){
    die "$avsFile not found\n" if (! -e $avsFile);

    #Global variables
    my %tally;
    my %heatmap;
    my $tagSNPs = loadTagSNPs($avsFile);
    my $outputVse = $outputPrefix.".VSE.txt";
    my $outputMatrix = $outputPrefix.".matrix.txt";

    #QC
    if ($bedDir =~ m/(bed|peak|gz)$/i){
	printLog("single bed file provided. Output will be printed on screen");
	die "$bedDir could not be located\n" if (! -e $bedDir);	
    } else {
	if (! -d $bedDir){
	    print "Directory path not found\n";
	}
    }

    #Reading bed files
    if ($bedDir =~ m/(bed|peak|gz)$/i){ #single annotation provided
	my $bedfile = $bedDir;
	die "Is the bed file zipped?\n" if $bedfile =~ m/(gz|zip|tar)$/;
	printLog("Reading $bedfile");

	#Load bed to a hash
	my (%POS2, %seenCHR2);
	foreach my $n (1..22,"X","Y"){
	    my $chr ="chr".$n; my @TMP;
	    @{$POS2{$chr}}=@TMP;
	}
	open (IN, "<$bedfile") or die;
	while (<IN>){
	    chomp;
	    my @f = split (/\t/, $_);
	    my ($chr,$s,$e) = ($f[0],$f[1],$f[2]);
	    if (!$seenCHR2{$chr}){$seenCHR2{$chr}=1}
	    my $rec = {S=>$s, E=>$e};
	    push @{$POS2{$chr}},$rec;
	}
	close IN;

        my ($tally, $overlapsRef) = LDX_v_bed($avsFile, \%POS2); #count tally for enrichment and density plot
        $tally{$bedfile}->{'AVS'} = $tally;
	foreach my $tagSNP (@$tagSNPs){
	    $heatmap{$bedfile}->{$tagSNP} = exists $overlapsRef->{$tagSNP} ? 1 : 0;
	}
        opendir (MRVdir, $mrvsDir) or die "Error in opening dir $mrvsDir\n";
        while (my $mrvfile = readdir(MRVdir)){
	    next if ($mrvfile !~ m/\d/);
	    #print "$mrvfile";
	    $mrvfile = $mrvsDir."/".$mrvfile;
            my ($tally, $overlapsRef) = LDX_v_bed($mrvfile, \%POS2);
            $tally{$bedfile}->{$mrvfile} = $tally;
	    #print "\t$tally\n";
        }
        closedir (MRVdir);
	foreach my $bed ( keys %tally){
	    foreach my $mrv (keys %{$tally{$bed}}){
		next if $mrv eq "AVS";
	    }
	    my $bedfileName = removeExtension($bedfile);
	}
    } else { #a directory of bed files provided
	opendir (DIR, $bedDir) or die "Error in opening dir $bedDir\n";
	while (my $bedfile= readdir(DIR)){
	    next if ($bedfile !~ m/bed$/i && $bedfile !~ m/peak$/i);
	    printLog("Reading $bedDir/$bedfile");
	    my $bedPath = $bedDir."/".$bedfile;

	    #Load bed to a hash
	    my %POS2;
	    foreach my $t (1..22,"X","Y"){
		my $chr ="chr".$t; my @TMP;
		@{$POS2{$chr}}=@TMP;
	    }
	    open (IN, "<$bedPath") or die;
	    while (<IN>){
		chomp;
		my @f = split (/\t/, $_);
		my ($chr,$s,$e) = ($f[0],$f[1],$f[2]);
		my $rec = {S=>$s, E=>$e};
		push @{$POS2{$chr}},$rec;
	    }
	    close IN;

	    foreach my $chr (keys %POS2){
		@{$POS2{$chr}} = sort {$a->{S} <=> $b->{S} ||$a->{E} <=> $b->{E}} @{$POS2{$chr}};
	    }

	    my ($tally, $overlapsRef) = LDX_v_bed($avsFile, \%POS2);
	    $tally{$bedfile}->{'AVS'} = $tally;
	    foreach my $tagSNP (@$tagSNPs){
		$heatmap{$bedfile}->{$tagSNP} = exists $overlapsRef->{$tagSNP} ? 1 : 0;
	    }
	    opendir (MRVdir, $mrvsDir) or die "Error in opening dir $mrvsDir\n";
	    while (my $mrvfile = readdir(MRVdir)){
		next if ($mrvfile !~ m/\d/);
		$mrvfile = $mrvsDir."/".$mrvfile;
		my ($tally, $overlapsRef) = LDX_v_bed($mrvfile, \%POS2);
		$tally{$bedfile}->{$mrvfile} = $tally;
	    }
	    closedir (MRVdir);
	}
	closedir (DIR);
	
	open (OUT, ">$outputVse") or die;
	foreach my $bed ( keys %tally){
	    print OUT $tally{$bed}->{'AVS'};
	    foreach my $mrv (keys %{$tally{$bed}}){
		next if $mrv eq "AVS";
		print OUT "\t".$tally{$bed}->{$mrv};
	    }
	    my $bedfileName = removeExtension($bed);
	    print OUT "\t".$bedfileName."\n";
	}
	close OUT;
    }
    open (OUT, ">$outputMatrix") or die;
    print OUT "Annotation";
    for my $tagSNP (@$tagSNPs){
	print OUT "\t$tagSNP";
    }
    print OUT "\n";
    foreach my $bedName (keys %heatmap){
	my $bedfileName = removeExtension($bedName);
	print OUT $bedfileName;
	for my $tagSNP (@$tagSNPs){
	    print OUT "\t".$heatmap{$bedName}->{$tagSNP};
	}
	print OUT "\n";
    }
    close OUT;
}
#------------------------------

#--------------R---------------
if ($program =~ m/stat/){

    #Check R 3.1.1
    my $toolName = "Rscript";
    my $toolPath = '';
    for my $path ( split (/:/, $ENV{PATH}) ) {
	if ( -f "$path/$toolName" && -x _ ) {
	    print "$toolName found in $path\n";
	    $toolPath = "$path/$toolName";
	    last;
	}
    }
    die "No $toolName command available. VSE requires R version 3.1.1 or above to function.\n" unless ( $toolPath );

    die "$vseFile not found\n" if (! -e $vseFile);
    die "$matrixFile not found\n" if (! -e $matrixFile);
    my @arr = split (/\./, $vseFile);
    pop @arr;
    my $prefix = join (".",@arr);
    my $outputBoxplot = $prefix.".boxplot.pdf";
    my $outputMatrix = $prefix.".matrix.pdf";
    my $outputDensity = $prefix.".density.pdf";
    my $outputVseStat = $prefix.".stat.txt";
    open (OUT, ">$outputVseStat") or die;
    printLog("Generating figures");
     my $Routput = `Rscript $scriptDir/lib/stat.r $vseFile $matrixFile $outputBoxplot $outputDensity $outputMatrix $bgSize  | grep \"^\\[1\\]\" | sort -k8rn`;
    $Routput =~ s/\[1\]//g;
    print OUT $Routput;
    close OUT;
}
#-----------------------------
